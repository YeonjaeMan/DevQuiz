import '../../model/problem.dart';

List<Problem> algorithms = [
  Problem(
    index: 0,
    question: "다음 중 정렬 알고리즘이 아닌 것은?",
    options: ["버블 정렬", "퀵 정렬", "이진 탐색", "병합 정렬"],
    answer: "이진 탐색",
    solution:
        "이진 탐색은 정렬된 배열에서 특정 값을 찾기 위한 알고리즘입니다. 반면, 버블 정렬, 퀵 정렬, 병합 정렬은 모두 데이터를 정렬하는 알고리즘입니다.",
  ),
  Problem(
    index: 1,
    question: "다음 중 최악의 경우 시간 복잡도가 O(n^2)인 정렬 알고리즘은?",
    options: ["퀵 정렬", "버블 정렬", "힙 정렬", "병합 정렬"],
    answer: "버블 정렬",
    solution: "버블 정렬은 최악의 경우 O(n^2)의 시간 복잡도를 가지며, 퀵 정렬은 평균적으로 O(n log n)입니다.",
  ),
  Problem(
    index: 2,
    question: "다음 중 그래프의 깊이 우선 탐색(DFS)에서 사용하는 자료구조는?",
    options: ["큐", "스택", "리스트", "트리"],
    answer: "스택",
    solution: "깊이 우선 탐색(DFS)은 스택을 사용하여 구현됩니다. 이는 가장 깊은 노드를 먼저 방문하는 방식입니다.",
  ),
  Problem(
    index: 3,
    question: "다음 중 Dijkstra 알고리즘의 주된 목적은 무엇인가?",
    options: ["최소 비용 경로 찾기", "정렬된 배열 만들기", "최대 이익 찾기", "해시 테이블 생성"],
    answer: "최소 비용 경로 찾기",
    solution: "Dijkstra 알고리즘은 그래프에서 시작 노드에서 다른 모든 노드까지의 최단 경로를 찾는 알고리즘입니다.",
  ),
  Problem(
    index: 4,
    question: "다음 중 이진 탐색 트리(BST)의 특징이 아닌 것은?",
    options: [
      "왼쪽 서브트리는 항상 부모 노드보다 작은 값",
      "오른쪽 서브트리는 항상 부모 노드보다 큰 값",
      "모든 노드는 최대 두 개의 자식 노드를 가질 수 있다",
      "노드는 중복될 수 있다"
    ],
    answer: "노드는 중복될 수 있다",
    solution: "이진 탐색 트리(BST)에서는 중복된 노드를 허용하지 않습니다. 각 노드는 고유한 값을 가져야 합니다.",
  ),
  Problem(
    index: 5,
    question: "다음 중 동적 프로그래밍의 특징은 무엇인가?",
    options: [
      "문제를 작은 하위 문제로 나눈다",
      "하위 문제의 결과를 재사용한다",
      "모든 경우를 탐색한다",
      "단순한 반복문으로 해결된다"
    ],
    answer: "하위 문제의 결과를 재사용한다",
    solution: "동적 프로그래밍은 하위 문제의 결과를 저장하여 중복 계산을 피하는 방식으로 문제를 해결합니다.",
  ),
  Problem(
    index: 6,
    question: "다음 중 해시 테이블의 장점은 무엇인가?",
    options: [
      "정렬된 데이터를 제공한다",
      "O(1)의 평균 검색 속도",
      "메모리 사용량이 적다",
      "링크드 리스트를 사용한다"
    ],
    answer: "O(1)의 평균 검색 속도",
    solution: "해시 테이블은 평균적으로 O(1)의 시간 복잡도로 데이터를 검색할 수 있어 매우 효율적입니다.",
  ),
  Problem(
    index: 7,
    question: "다음 중 퀵 정렬의 평균 시간 복잡도는?",
    options: ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
    answer: "O(n log n)",
    solution:
        "퀵 정렬의 평균 시간 복잡도는 O(n log n)입니다. 최악의 경우는 O(n^2)일 수 있으나, 일반적으로 빠른 정렬 알고리즘으로 알려져 있습니다.",
  ),
  Problem(
    index: 8,
    question: "다음 중 최소 신장 트리를 찾기 위한 알고리즘은?",
    options: ["프림 알고리즘", "다익스트라 알고리즘", "플로이드-워셜 알고리즘", "KMP 알고리즘"],
    answer: "프림 알고리즘",
    solution:
        "프림 알고리즘은 그래프의 최소 신장 트리를 찾기 위한 알고리즘입니다. 다익스트라 알고리즘은 최단 경로를 찾는 알고리즘입니다.",
  ),
  Problem(
    index: 9,
    question: "다음 중 BFS(너비 우선 탐색)의 특징은?",
    options: ["최단 경로를 보장한다", "스택을 사용한다", "큐를 사용한다", "그래프의 노드를 깊이 우선으로 방문한다"],
    answer: "큐를 사용한다",
    solution: "BFS는 큐 자료구조를 사용하여 구현되며, 각 노드를 너비 우선으로 방문합니다.",
  ),
  Problem(
    index: 10,
    question: "다음 중 최적화 문제를 해결하기 위한 기법은?",
    options: ["브루트 포스", "탐욕 알고리즘", "분할 정복", "재귀"],
    answer: "탐욕 알고리즘",
    solution: "탐욕 알고리즘은 최적화 문제를 해결하기 위해 각 단계에서 최적의 선택을 하는 방법입니다.",
  ),
  Problem(
    index: 11,
    question: "다음 중 배열을 사용하는 자료구조는?",
    options: ["스택", "큐", "링크드 리스트", "트리"],
    answer: "스택",
    solution: "스택과 큐는 배열 또는 링크드 리스트로 구현할 수 있지만, 스택은 배열을 사용하여 구현되는 경우가 많습니다.",
  ),
  Problem(
    index: 12,
    question: "다음 중 그래프의 인접 리스트 표현 방식의 장점은?",
    options: [
      "메모리 사용이 적다",
      "모든 엣지를 쉽게 찾을 수 있다",
      "정렬된 그래프를 지원한다",
      "모든 노드를 순차적으로 방문할 수 있다"
    ],
    answer: "메모리 사용이 적다",
    solution: "인접 리스트는 그래프의 노드 수와 엣지 수에 따라 메모리를 효율적으로 사용할 수 있는 방법입니다.",
  ),
  Problem(
    index: 13,
    question: "다음 중 배열의 요소를 순회하는 반복문은?",
    options: ["for", "while", "do-while", "모두"],
    answer: "모두",
    solution: "배열의 요소를 순회하는 데는 for, while, do-while 모두 사용할 수 있습니다.",
  ),
  Problem(
    index: 14,
    question: "다음 중 정렬 알고리즘에서 안정성을 보장하는 알고리즘은?",
    options: ["버블 정렬", "퀵 정렬", "힙 정렬", "병합 정렬"],
    answer: "버블 정렬",
    solution: "버블 정렬과 병합 정렬은 안정적인 정렬 알고리즘입니다. 즉, 동일한 값의 요소 순서가 유지됩니다.",
  ),
  Problem(
    index: 15,
    question: "다음 중 그래프를 표현하는 방법이 아닌 것은?",
    options: ["인접 행렬", "인접 리스트", "해시 맵", "변수"],
    answer: "변수",
    solution:
        "그래프는 인접 행렬과 인접 리스트로 표현할 수 있으며, 해시 맵도 그래프의 일부 구조를 표현하는 데 사용할 수 있지만, 변수는 그래프 표현의 방법이 아닙니다.",
  ),
  Problem(
    index: 16,
    question: "다음 중 최단 경로 알고리즘의 예가 아닌 것은?",
    options: ["다익스트라 알고리즘", "벨만-포드 알고리즘", "A* 알고리즘", "퀵 정렬"],
    answer: "퀵 정렬",
    solution: "퀵 정렬은 정렬 알고리즘이며, 최단 경로를 찾는 알고리즘과는 관련이 없습니다.",
  ),
  Problem(
    index: 17,
    question: "다음 중 이진 검색 트리의 검색 시간 복잡도는?",
    options: ["O(1)", "O(log n)", "O(n)", "O(n^2)"],
    answer: "O(log n)",
    solution:
        "이진 검색 트리의 평균적인 검색 시간 복잡도는 O(log n)입니다. 하지만 최악의 경우(트리가 편향되어 있을 때)에는 O(n)일 수 있습니다.",
  ),
  Problem(
    index: 18,
    question: "다음 중 그래프의 순회 방법이 아닌 것은?",
    options: ["너비 우선 탐색(BFS)", "깊이 우선 탐색(DFS)", "다익스트라 알고리즘", "프림 알고리즘"],
    answer: "다익스트라 알고리즘",
    solution: "다익스트라 알고리즘은 최단 경로를 찾는 알고리즘이지 그래프를 순회하는 방법은 아닙니다.",
  ),
  Problem(
    index: 19,
    question: "다음 중 동적 프로그래밍의 특징은?",
    options: ["최적 부분 구조", "중복 부분 문제", "탐욕적 방법", "상태 전이"],
    answer: "탐욕적 방법",
    solution:
        "탐욕적 방법은 동적 프로그래밍과는 다른 접근 방식으로, 동적 프로그래밍에서는 최적 부분 구조와 중복 부분 문제가 중요한 특징입니다.",
  )
];
