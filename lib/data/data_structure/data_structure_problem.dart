import '../../model/problem.dart';

List<Problem> dataStructures = [
  Problem(
    index: 0,
    question: "다음 중 배열의 특징이 아닌 것은?",
    options: [
      "연속적인 메모리 공간을 차지한다",
      "동일한 데이터 타입의 요소를 저장한다",
      "크기를 동적으로 변경할 수 있다",
      "인덱스를 사용하여 접근한다"
    ],
    answer: "크기를 동적으로 변경할 수 있다",
    solution: "배열은 고정 크기를 가지며, 한 번 선언된 후에는 크기를 동적으로 변경할 수 없습니다.",
  ),
  Problem(
    index: 1,
    question: "다음 중 링크드 리스트의 장점은 무엇인가?",
    options: [
      "메모리 공간의 낭비가 없다",
      "효율적인 인덱스 접근",
      "삽입과 삭제가 용이하다",
      "크기를 동적으로 변경할 수 있다"
    ],
    answer: "삽입과 삭제가 용이하다",
    solution: "링크드 리스트는 노드 간의 연결로 이루어져 있어, 삽입과 삭제가 배열보다 용이합니다.",
  ),
  Problem(
    index: 2,
    question: "다음 중 스택의 특징이 아닌 것은?",
    options: [
      "후입선출(LIFO) 구조",
      "임의 접근이 가능하다",
      "푸시(push)와 팝(pop) 연산을 사용한다",
      "정적 또는 동적으로 구현할 수 있다"
    ],
    answer: "임의 접근이 가능하다",
    solution: "스택은 후입선출 구조로, 임의 접근이 불가능합니다. 오직 가장 최근에 추가된 요소만 접근할 수 있습니다.",
  ),
  Problem(
    index: 3,
    question: "다음 중 큐의 특징은 무엇인가?",
    options: [
      "선입선출(FIFO) 구조",
      "임의 접근이 가능하다",
      "가장 최근에 추가된 요소가 먼저 나간다",
      "노드가 연결되어 있다"
    ],
    answer: "선입선출(FIFO) 구조",
    solution: "큐는 선입선출 구조로, 먼저 들어온 요소가 먼저 나갑니다.",
  ),
  Problem(
    index: 4,
    question: "다음 중 이진 트리의 모든 노드가 최대 두 개의 자식을 가지는 트리는 무엇인가?",
    options: ["이진 탐색 트리", "완전 이진 트리", "균형 이진 트리", "이진 트리"],
    answer: "이진 트리",
    solution: "이진 트리는 각 노드가 최대 두 개의 자식을 가질 수 있는 트리 구조입니다.",
  ),
  Problem(
    index: 5,
    question: "다음 중 그래프의 표현 방법이 아닌 것은?",
    options: ["인접 행렬", "인접 리스트", "해시 테이블", "간선 리스트"],
    answer: "해시 테이블",
    solution: "해시 테이블은 그래프를 표현하는 방법이 아니라, 데이터를 키-값 쌍으로 저장하는 자료구조입니다.",
  ),
  Problem(
    index: 6,
    question: "다음 중 해시 충돌을 해결하는 방법이 아닌 것은?",
    options: ["체이닝", "개방 주소법", "이진 탐색 트리", "이중 해싱"],
    answer: "이진 탐색 트리",
    solution: "이진 탐색 트리는 해시 충돌을 해결하는 방법이 아니라, 정렬된 데이터를 저장하는 자료구조입니다.",
  ),
  Problem(
    index: 7,
    question: "다음 중 힙의 특징은 무엇인가?",
    options: [
      "모든 노드가 자식 노드보다 크다",
      "완전 이진 트리 구조",
      "최소 힙과 최대 힙이 있다",
      "모든 노드가 자식 노드보다 작다"
    ],
    answer: "완전 이진 트리 구조",
    solution: "힙은 완전 이진 트리 구조를 가지고 있으며, 최소 힙과 최대 힙 두 가지 형태가 있습니다.",
  ),
  Problem(
    index: 8,
    question: "다음 중 이진 탐색의 시간 복잡도는?",
    options: ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
    answer: "O(log n)",
    solution: "이진 탐색의 시간 복잡도는 O(log n)으로, 정렬된 배열에서 효율적으로 요소를 찾는 방법입니다.",
  ),
  Problem(
    index: 9,
    question: "다음 중 다익스트라 알고리즘의 주 용도는 무엇인가?",
    options: ["최단 경로를 찾기 위해", "정렬을 위해", "그래프의 순환을 탐지하기 위해", "최대 유량을 계산하기 위해"],
    answer: "최단 경로를 찾기 위해",
    solution: "다익스트라 알고리즘은 가중치가 있는 그래프에서 최단 경로를 찾기 위해 사용됩니다.",
  ),
  Problem(
    index: 10,
    question: "다음 중 트리의 깊이를 구하는 방법은?",
    options: ["너비 우선 탐색(BFS)", "깊이 우선 탐색(DFS)", "정렬", "해시 탐색"],
    answer: "깊이 우선 탐색(DFS)",
    solution: "트리의 깊이를 구하는 데는 깊이 우선 탐색(DFS)을 사용하여 각 노드를 탐색합니다.",
  ),
  Problem(
    index: 11,
    question: "다음 중 자료구조에서의 '균형'이란 무엇을 의미하는가?",
    options: ["모든 요소가 동일한 크기", "노드의 수가 동일함", "트리의 높이가 최소화됨", "모든 노드가 동일한 깊이"],
    answer: "트리의 높이가 최소화됨",
    solution: "균형은 트리의 높이를 최소화하여 효율적인 탐색을 가능하게 하는 것을 의미합니다.",
  ),
  Problem(
    index: 12,
    question: "다음 중 그래프에서 노드의 차수를 구하는 방법은?",
    options: ["인접 행렬 사용", "노드의 위치 찾기", "DFS 이용", "BFS 이용"],
    answer: "인접 행렬 사용",
    solution: "인접 행렬을 사용하여 특정 노드의 차수를 쉽게 구할 수 있습니다.",
  ),
  Problem(
    index: 13,
    question: "다음 중 재귀 호출의 특징은 무엇인가?",
    options: ["함수가 자기 자신을 호출한다", "반복문을 사용한다", "메모리 공간을 절약한다", "항상 종료된다"],
    answer: "함수가 자기 자신을 호출한다",
    solution: "재귀 호출은 함수가 자기 자신을 호출하는 방법으로, 종료 조건이 없으면 무한 루프에 빠질 수 있습니다.",
  ),
  Problem(
    index: 14,
    question: "다음 중 큐에서 요소를 제거하는 연산은 무엇인가?",
    options: ["push", "pop", "enqueue", "dequeue"],
    answer: "dequeue",
    solution: "큐에서 요소를 제거하는 연산은 dequeue입니다. 반면 push는 스택에 요소를 추가하는 연산입니다.",
  ),
  Problem(
    index: 15,
    question: "다음 중 이진 검색 트리의 성질은 무엇인가?",
    options: [
      "왼쪽 서브트리는 항상 오른쪽 서브트리보다 작다",
      "모든 노드는 두 개의 자식을 가진다",
      "트리의 모든 노드는 정렬되어 있다",
      "모든 노드는 최대 세 개의 자식을 가진다"
    ],
    answer: "왼쪽 서브트리는 항상 오른쪽 서브트리보다 작다",
    solution:
        "이진 검색 트리에서는 왼쪽 서브트리의 모든 노드가 부모 노드보다 작고, 오른쪽 서브트리의 모든 노드가 부모 노드보다 큽니다.",
  ),
  Problem(
    index: 16,
    question: "다음 중 그래프의 연결성을 확인하는 방법은?",
    options: ["DFS", "정렬", "해시", "스택"],
    answer: "DFS",
    solution: "DFS(깊이 우선 탐색)를 사용하여 그래프의 연결성을 확인할 수 있습니다.",
  ),
  Problem(
    index: 17,
    question: "다음 중 자료구조에서 '해시 함수'의 역할은 무엇인가?",
    options: [
      "데이터를 정렬한다",
      "데이터를 키-값 쌍으로 저장한다",
      "데이터를 검색하는 속도를 높인다",
      "데이터의 중복을 제거한다"
    ],
    answer: "데이터를 검색하는 속도를 높인다",
    solution:
        "해시 함수는 데이터를 해시 테이블에 저장할 때, 검색 속도를 높이기 위해 데이터를 특정한 위치에 매핑하는 역할을 합니다.",
  ),
  Problem(
    index: 18,
    question: "다음 중 '정렬' 알고리즘이 아닌 것은?",
    options: ["버블 정렬", "삽입 정렬", "선택 정렬", "다익스트라 알고리즘"],
    answer: "다익스트라 알고리즘",
    solution: "다익스트라 알고리즘은 최단 경로를 찾기 위한 알고리즘이지, 정렬 알고리즘이 아닙니다.",
  ),
  Problem(
    index: 19,
    question: "다음 중 이진 검색 트리를 사용하는 이유는 무엇인가?",
    options: [
      "데이터를 정렬하기 위해",
      "데이터의 삽입과 삭제가 용이하기 위해",
      "효율적인 검색을 위해",
      "모든 데이터가 동일한 크기를 가져야 하기 때문에"
    ],
    answer: "효율적인 검색을 위해",
    solution:
        "이진 검색 트리는 데이터를 효율적으로 검색하기 위해 사용되며, 평균적으로 O(log n)의 시간 복잡도를 가집니다.",
  ),
];
